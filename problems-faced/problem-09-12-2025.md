
# **Major Engineering Challenges Faced While Setting Up the Backend Infrastructure**

### *(PostgreSQL + Prisma v7 + Next.js Backend Architecture)*

This document summarises the key complexities I encountered while setting up the backend foundation for AdhyayanX, the debugging process, and the engineering decisions made to resolve them. These points demonstrate hands-on problem-solving, system-level understanding, and ability to navigate breaking changes and environment conflicts — all of which are important in backend/platform roles.

---

# **1. Handling Prisma v7 Breaking Changes (Datasource + Driver Adapters)**

### **Problem:**

Prisma recently introduced a major architectural shift in v7 by removing datasource URLs from `schema.prisma` and mandating the use of driver adapters (like `@prisma/adapter-pg`).
Initially, I followed traditional Prisma setup documentation, which led to errors like:

* **P1012 — Datasource URL no longer supported**
* **PrismaClientInitializationError — missing adapter**

These errors were new and not widely documented yet.

### **Why It Was Complex:**

This was not a syntax issue — it was a breaking change in how Prisma generates runtime clients.
Most online resources still reflect Prisma v4/v5 patterns.

### **How I Solved It:**

* Studied Prisma’s new RFCs and migration notes.
* Moved connection URL into `prisma.config.ts`.
* Implemented a runtime adapter using `PrismaPg` + `pg` connection pool.
* Updated seed scripts to work with the new runtime flow.

### **Outcome:**

I now have a fully future-compatible Prisma setup aligned with v7 architecture.
This demonstrates adaptability and quick assimilation of emerging tooling changes.

---

# **2. Database Shadow Environment Errors (P3014) During Migration**

### **Problem:**

`npx prisma migrate dev` failed due to:

```
Error: Could not create shadow database — permission denied
```

Prisma creates an internal “shadow DB” for diffing schema migrations.
Our database user (`adx_user`) lacked `CREATEDB` permissions.

### **Why It Was Complex:**

This wasn’t obvious from the error message, and the shadow DB mechanism is not widely understood for junior engineers.

### **How I Solved It:**

* Understood how Prisma computes diffs via temporary databases.
* Granted internal DB privileges:

```sql
ALTER USER adx_user CREATEDB;
```

* Re-ran migrations successfully.

### **Outcome:**

Smooth migration pipeline now working — crucial for schema evolution in production.

---

# **3. Schema Permission Errors in Postgres (Ownership & ACL Conflicts)**

### **Problem:**

I faced:

```
permission denied for schema public
```

even though the DB user had full DB privileges.

### **Why It Was Complex:**

Postgres privileges work on multiple layers:

* Database level
* Schema level
* Table level
* Sequence level

Many developers miss that **owning a database does NOT give rights inside the public schema**.

### **How I Solved It:**

I explicitly granted schema privileges:

```sql
GRANT USAGE ON SCHEMA public TO adx_user;
GRANT CREATE ON SCHEMA public TO adx_user;
GRANT ALL PRIVILEGES ON ALL TABLES IN SCHEMA public TO adx_user;
GRANT ALL PRIVILEGES ON ALL SEQUENCES IN SCHEMA public TO adx_user;
```

### **Outcome:**

Prisma migrations and seed scripts executed without any ACL issues.

---
# **4. Relationship Misconfiguration Between `Institute` and `Batch`**

### **Problem:**

Prisma threw:

```
Error validating field `batches` in model `Institute`: missing opposite relation field
```

### **Why It Was Complex:**

This is a typical relational modeling challenge — but Prisma makes it strict:
Every `1:N` relation must be explicitly defined on both sides.

### **How I Solved It:**

Added the correct opposite relation:

```prisma
institute   Institute? @relation(fields: [instituteId], references: [id])
instituteId String?
```

### **Outcome:**

Relational integrity fully restored; migrations succeeded.

---

# **5. Seed Script Not Executing Beyond First User Check**

### **Problem:**

Seed logs only showed:

```
SUPERADMIN already exists
```

But nothing else seeded.

### **Why It Was Complex:**

There were *multiple overlapping issues*:

* Prisma client not regenerated
* Adapter not connected
* Some migration inconsistencies

The script failed silently before running rest of the code.

### **How I Solved It:**

* Added debug instrumentation (`console.log` checks for model existence).
* Confirmed client missing models → regenerated.

```bash
npx prisma generate
```

* Re-ran seed - successful.

### **Outcome:**

Stable, idempotent seed mechanism usable across all developers and CI pipelines.

---

# **6. Ensuring Reproducibility Across Team Members**

### **Problem:**

Developers often face issues where setups differ across machines (Postgres version, permissions, env inconsistencies).

### **Why It Was Complex:**

A backend setup is only as good as its reproducibility.

### **How I Solved It:**

* Created a canonical `.env.example`.
* Documented all commands precisely.
* Provided a Docker alternative for identical cross-machine behaviour.
* Created a seed-based reproducible baseline for all environments.

### **Outcome:**

Any engineer can replicate the backend environment in ~10 minutes without asking for help.

---

# **7. Managing Cross-Tool Integration (Next.js + Prisma + Postgres)**

### **Problem:**

Next.js App Router requires special care when using long-lived resources like Prisma clients.

### **Why It Was Complex:**

Incorrect client instantiation leads to:

* memory leaks
* too many DB connections
* high latency in local development

### **How I Solved It:**

* Ensured Prisma client created once (`lib/prisma.ts`).
* Used connection pooling via `pg` to prevent over-connection.

### **Outcome:**

A stable backend foundation ready for real-world traffic.

---
